// Copyright (c) 2015  GeometryFactory (France).  All rights reserved.
//
// This file is part of CGAL (www.cgal.org)
//
// $URL$
// $Id$
// SPDX-License-Identifier: LGPL-3.0-or-later OR LicenseRef-Commercial
//
// Author(s)     : Andreas Fabri
//                 Mael Rouxel-Labb√©

#ifndef CGAL_BGL_IO_PLY_H
#define CGAL_BGL_IO_PLY_H

#include <CGAL/IO/PLY.h>

#include <CGAL/boost/graph/Named_function_parameters.h>
#include <CGAL/boost/graph/named_params_helper.h>

#include <fstream>

namespace CGAL {

template <class FaceGraph>
bool write_PLY(std::ostream& out,
               const FaceGraph& mesh)
{
  typedef typename boost::graph_traits<FaceGraph>::vertex_descriptor          vertex_descriptor;
  typedef typename boost::graph_traits<FaceGraph>::halfedge_descriptor        halfedge_descriptor;
  typedef typename boost::graph_traits<FaceGraph>::face_descriptor            face_descriptor;

  typedef typename boost::property_map<FaceGraph, boost::vertex_point_t>::type::value_type Point_3;

  // @fixme
  typedef typename FaceGraph::template Property_map<halfedge_descriptor,std::pair<float, float> > UV_map;

  UV_map h_uv;
  bool has_texture;
  boost::tie(h_uv, has_texture) = mesh.template property_map<halfedge_descriptor,std::pair<float, float> >("h:uv");

  if(!out.good())
  {
    std::cerr << "Error: cannot open file" << std::endl;
    return false;
  }

  // Write header
  out << "ply" << std::endl
      << ((get_mode(out) == IO::BINARY) ? "format binary_little_endian 1.0" : "format ascii 1.0") << std::endl
      << "comment Generated by the CGAL library" << std::endl
      << "element vertex " << num_vertices(mesh) << std::endl;

  IO::internal::output_property_header(out, make_ply_point_writer (CGAL::Identity_property_map<Point_3>()));

  out << "element face " << num_faces(mesh) << std::endl;

  IO::internal::output_property_header(out, std::make_pair(CGAL::Identity_property_map<std::vector<std::size_t> >(),
                                                           PLY_property<std::vector<int> >("vertex_indices")));

  if(has_texture)
  {
    out << "element halfedge " << num_halfedges(mesh) << std::endl;

    IO::internal::output_property_header(out, std::make_pair(CGAL::Identity_property_map<std::size_t >(),
                                                             PLY_property<unsigned int >("source")));
    IO::internal::output_property_header(out, std::make_pair(CGAL::Identity_property_map<std::size_t >(),
                                                             PLY_property<unsigned int >("target")));
    IO::internal::output_property_header(out, std::make_tuple(h_uv,
                                                              PLY_property<float>("u"),
                                                              PLY_property<float>("v")));
  }
  out << "end_header" << std::endl;

  for(vertex_descriptor vd : vertices(mesh))
  {
    Point_3 p = get(get(CGAL::vertex_point, mesh), vd);
    IO::internal::output_properties(out, &p, make_ply_point_writer (CGAL::Identity_property_map<Point_3>()));
  }

  std::vector<std::size_t> polygon;
  for(face_descriptor fd : faces(mesh))
  {
    polygon.clear();
    for(halfedge_descriptor hd : halfedges_around_face(halfedge(fd, mesh), mesh))
      polygon.push_back(get(get(boost::vertex_index, mesh), target(hd,mesh)));

    IO::internal::output_properties(out, &polygon,
                                     std::make_pair(CGAL::Identity_property_map<std::vector<std::size_t> >(),
                                                    PLY_property<std::vector<int> >("vertex_indices")));
  }

  if(has_texture)
  {
    for(halfedge_descriptor hd : halfedges(mesh))
    {
      typedef std::tuple<unsigned int, unsigned int, float, float> Super_tuple;
      Super_tuple t = std::make_tuple(source(hd, mesh),target(hd, mesh),
                                      h_uv[hd].first,
                                      h_uv[hd].second);

      IO::internal::output_properties(out, &t,
                                      std::make_pair(Nth_of_tuple_property_map<0,Super_tuple>(),
                                                     PLY_property<unsigned int >("source")),
                                      std::make_pair(Nth_of_tuple_property_map<1,Super_tuple>(),
                                                     PLY_property<unsigned int >("target")),
                                      std::make_pair(Nth_of_tuple_property_map<2,Super_tuple>(),
                                                     PLY_property<float>("u")),
                                      std::make_pair(Nth_of_tuple_property_map<3,Super_tuple>(),
                                                     PLY_property<float>("v")));
    }
  }

  return out.good();
}

// @fixme add overloads

} // namespace CGAL

#endif // CGAL_BGL_IO_PLY_H
